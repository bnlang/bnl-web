---
title: JavaScript Asynchronous Programming & Callbacks
description: A self-contained guide to asynchronous programming and callbacks in Bnlang with Bangla and English examples.
bnTitle: জাভাস্ক্রিপ্ট অ্যাসিঙ্ক্রোনাস প্রোগ্রামিং ও কলব্যাক
bnDescription: Bnlang এ অ্যাসিঙ্ক্রোনাস প্রোগ্রামিং ও কলব্যাকের ব্যবহার, সমস্যা এবং সমাধানসহ উদাহরণ।
---

# <I18nEnglish>JavaScript Asynchronous Programming & Callbacks</I18nEnglish>
# <I18nBangla>জাভাস্ক্রিপ্ট অ্যাসিঙ্ক্রোনাস প্রোগ্রামিং ও কলব্যাক</I18nBangla>

<I18nEnglish>
In **Bnlang**, asynchronous programming lets your program start tasks (like network requests, file access, or timers) and continue running without waiting.  
A **callback** is a function you pass to another function to be invoked later, typically after an asynchronous operation finishes.  
This page explains the callback pattern, error-first callbacks, common pitfalls (callback hell), and safer alternatives.
</I18nEnglish>

<I18nBangla>
**Bnlang** এ অ্যাসিঙ্ক্রোনাস প্রোগ্রামিং এমনভাবে কাজ করে যেখানে নেটওয়ার্ক, ফাইল বা টাইমার চালু রেখেও বাকি কোড চলতে থাকে।  
**কলব্যাক** হল এমন ফাংশন যা অন্য ফাংশনে পাঠানো হয় এবং কাজ শেষ হলে পরে ডাকা হয়।  
এখানে কলব্যাক প্যাটার্ন, এরর-ফার্স্ট কলব্যাক, সাধারণ সমস্যা (কোলব্যাক হেল) এবং বিকল্প সমাধান নিয়ে আলোচনা করা হয়েছে।
</I18nBangla>

---

## The Event Loop in One Minute

<I18nEnglish>
Bnlang runs an event loop that manages queues of tasks. When an asynchronous operation completes, its callback is queued and executed when the call stack is free. This design keeps programs responsive.
</I18nEnglish>

<I18nBangla>
Bnlang একটি ইভেন্ট লুপ চালায় যা টাস্কের কিউ ম্যানেজ করে। অ্যাসিঙ্ক কাজ শেষ হলে তার কলব্যাক কিউতে যোগ হয় এবং কল স্ট্যাক ফাঁকা হলে চালানো হয়। এতে প্রোগ্রাম রেসপন্সিভ থাকে।
</I18nBangla>

---

## Basic Callback Pattern

<Tabs defaultValue="bangla" className="w-full">
  <TabsList>
    <TabsTrigger value="bangla">Bangla</TabsTrigger>
    <TabsTrigger value="english">English</TabsTrigger>
  </TabsList>

  <TabsContent value="english">

```js
function readLater(callback) {
  setTimeout(() => {
    callback(null, "Done reading!");
  }, 500);
}

readLater((err, data) => {
  if (err) {
    console.error("Failed:", err);
  } else {
    console.log("Result:", data);
  }
});
```
  </TabsContent>

  <TabsContent value="bangla">

```bnl
function পরে_পড়ো(কলব্যাক) {
  সময়সীমা_নির্ধারণ(() => {
    কলব্যাক(null, "পড়া শেষ!");
  }, 500);
}

পরে_পড়ো((এরর, ডাটা) => {
  যদি (এরর) {
    কনসোল.ত্রুটি("ব্যর্থ:", এরর);
  } নাহলে {
    কনসোল.লগ("ফলাফল:", ডাটা);
  }
});
```
  </TabsContent>

  
</Tabs>

---

## Error‑First Callbacks

<I18nEnglish>
A common convention is **error‑first** callbacks: the first argument is an error (if any), the second is the result. If `err` is not `null`, handle the error and do not use the result.
</I18nEnglish>

<I18nBangla>
প্রচলিত নিয়ম হলো **এরর‑ফার্স্ট** কলব্যাক: প্রথম আর্গুমেন্টে এরর (থাকলে), দ্বিতীয়টিতে রেজাল্ট। `err` `null` না হলে এরর হ্যান্ডল করুন এবং রেজাল্ট ব্যবহার করবেন না।
</I18nBangla>

<Tabs defaultValue="bangla" className="w-full">
  <TabsList>
    <TabsTrigger value="bangla">Bangla</TabsTrigger>
    
    <TabsTrigger value="english">English</TabsTrigger>
  </TabsList>

  <TabsContent value="english">

```js
function doWork(cb) {
  setTimeout(() => cb(null, 42), 300);
}

doWork((err, value) => {
  if (err) return console.error(err);
  console.log("Value:", value);
});
```
  </TabsContent>

  <TabsContent value="bangla">

```bnl
function কাজ_করো(কলব্যাক) {
  সময়সীমা_নির্ধারণ(() => কলব্যাক(null, 42), 300);
}

কাজ_করো((এরর, মান) => {
  যদি (এরর) ফেরত কনসোল.ত্রুটি(এরর);
  কনসোল.লগ("মান:", মান);
});
```
  </TabsContent>

  
</Tabs>

---

## Avoiding Callback Hell

<I18nEnglish>
- Break large functions into small, named functions and compose them.  
- Prefer **Promises** or **async/await** for sequential flow.  
- Reuse common error handlers.
</I18nEnglish>

<I18nBangla>
- বড় ফাংশন ভেঙে ছোট, নামযুক্ত ফাংশনে ভাগ করুন ও কম্পোজ করুন।  
- সিকোয়েন্সিয়াল ফ্লোর জন্য **প্রতিশ্রুতি** বা **async/await** ব্যবহার করুন।  
- সাধারণ এরর হ্যান্ডলার পুনঃব্যবহার করুন।
</I18nBangla>

---

## From Callback to Promise (Promisify)

<Tabs defaultValue="bangla" className="w-full">
  <TabsList>
    <TabsTrigger value="bangla">Bangla</TabsTrigger>
    
    <TabsTrigger value="english">English</TabsTrigger>
  </TabsList>

  <TabsContent value="english">

```js
function withCallback(a, b, cb) {
  setTimeout(() => cb(null, a + b), 200);
}

function withPromise(a, b) {
  return new Promise((resolve, reject) => {
    withCallback(a, b, (err, sum) => {
      if (err) reject(err);
      else resolve(sum);
    });
  });
}

withPromise(3, 4).then(console.log); // 7
```
  </TabsContent>

  <TabsContent value="bangla">

```bnl
function কলব্যাক_সহ(a, b, cb) {
  সময়সীমা_নির্ধারণ(() => cb(null, a + b), 200);
}

function প্রতিশ্রুতি_সহ(a, b) {
  ফেরত নতুন প্রতিশ্রুতি((রিজলভ, রিজেক্ট) => {
    কলব্যাক_সহ(a, b, (এরর, যোগফল) => {
      যদি (এরর) রিজেক্ট(এরর);
      নাহলে রিজলভ(যোগফল);
    });
  });
}

প্রতিশ্রুতি_সহ(3, 4).তারপর(কনসোল.লগ); // 7
```
  </TabsContent>

  
</Tabs>

---

## Mixing Callbacks with Timers

<Tabs defaultValue="bangla" className="w-full">
  <TabsList>
    <TabsTrigger value="bangla">Bangla</TabsTrigger>
    
    <TabsTrigger value="english">English</TabsTrigger>
  </TabsList>

  <TabsContent value="english">

```js
function pollUntilReady(isReady, done) {
  const id = setInterval(() => {
    if (isReady()) {
      clearInterval(id);
      done(null, "Ready!");
    }
  }, 100);
}
```
  </TabsContent>

  <TabsContent value="bangla">

```bnl
function প্রস্তুত_হওয়া_পর্যন্ত_পোল(isReady, done) {
  const আইডি = ইন্টারভ্যাল(() => {
    যদি (isReady()) {
      ক্লিয়ার_ইন্টারভ্যাল(আইডি);
      done(null, "প্রস্তুত!");
    }
  }, 100);
}
```
  </TabsContent>

  
</Tabs>

---

## Best Practices Recap

<I18nEnglish>
- Use error‑first callbacks consistently.  
- Keep callback functions pure and small.  
- Prefer promises/async‑await for complex flows.  
- Always clear timers you start.
</I18nEnglish>

<I18nBangla>
- সর্বত্র error‑first প্যাটার্ন অনুসরণ করুন।  
- কলব্যাকগুলো ছোট ও পার্শ্বপ্রভাব‑মুক্ত রাখুন।  
- জটিল ফ্লোতে প্রতিশ্রুতি বা async‑await ব্যবহার করুন।  
- নিজে শুরু করা টাইমার অবশ্যই ক্লিয়ার করুন।
</I18nBangla>

